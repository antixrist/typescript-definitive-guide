{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/Вывод типов","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}},"contentLevelUpInformer":{"text":"Кажется непонятным и слишком сложным? Чего-то не хватает? Расскажи об этом! Помоги сделать контент более доступным для следующих поколений!","buttons":[{"label":"Сообщить на Github","href":""}]}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Бесплатная pdf книга на русском по языку TypeScript."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Вывод типов","section":"Типизация","path":"vyvod tipov","subtitles":[{"subtitle":"Вывод типов - общие сведения","path":"vyvod tipov#vyvod tipov - obshchie svedeniya"},{"subtitle":"Вывод примитивных типов","path":"vyvod tipov#vyvod primitivnyh tipov"},{"subtitle":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"vyvod tipov#vyvod primitivnyh tipov dlya konstant (const) i polei tolko dlya chteniya (readonly)"},{"subtitle":"Вывод объектных типов","path":"vyvod tipov#vyvod obektnyh tipov"},{"subtitle":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"vyvod tipov#vyvod tipa dlya polei klassa na osnove inicializacii ih v konstruktore"},{"subtitle":"Вывод объединенных (Union) типов","path":"vyvod tipov#vyvod obedinennyh (union) tipov"},{"subtitle":"Вывод пересечения (Intersection) с дискриминантными полями","path":"vyvod tipov#vyvod peresecheniya (intersection) s diskriminantnymi polyami"},{"subtitle":"Вывод типов кортеж (Tuple)","path":"vyvod tipov#vyvod tipov kortej (tuple)"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод типов</span></h1><p class=\"content__paragraph\">Понимание темы относящейся к такому фундаментальному механизму как <em>вывод типов</em> поможет разработчику подчинить компилятор <em>tsc</em>, а не наоборот. Невозможно писать программы на языке <em>TypeScript</em> получая от процесса удовольствие, если нет однозначного ответа на вопрос \"указывать типы явно или нет\". Ответы на этот и другие сопряженные вопросы, как раз и содержит данная глава посвященная подробному рассмотрению каждого момента.</p></section>\n<section class=\"content__section\" id=\"Вывод типов - общие сведения\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod tipov - obshchie svedeniya\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод типов - общие сведения</span></h2><p class=\"content__paragraph\">Чтобы не повторять определения, которые были даны в главе <a href=\"/book/chapters/%D0%A1%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5,%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F,%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2\">“Экскурс в типизацию - Связывание, типизация, вывод типов”</a>, эту главу стоит начать с неформально определения.</p><p class=\"content__paragraph\"><em>Вывод типов</em> — это механизм позволяющий сделать процесс разработки на статически типизированном <em>TypeScript</em> более простой за счет перекладывания на него рутинной работы по явной аннотации типов. Может показаться что вывод типов берется за дело только тогда, когда при разборе кода попадается отсутствующая аннотация типа. Но это не так. Компилятор не доверяет разработчику и весь код, в штатном режиме, проходит через вывод типов. Не важно, в полной мере разработчик указывает типы определяемым им конструкциям или нет, чтобы их проверить на адекватность и совместимость, вывод типов обязан создать для них собственное описание (понимать как объявление типа).</p><p class=\"content__paragraph\">В этом механизме нет ничего сложного, но несмотря на это, у начинающих разработчиков <em>TypeScript</em>, некоторые неочевидные особенности могут вызвать вопросы, главным из которых является уже упомянутый в самом начале - \"указывать явно типы или нет\".</p><p class=\"content__paragraph\">Ответ очевиден и прост - во всех случаях допускающих отсутствие явной аннотации типа эту работу стоит поручать выводу типов. Другими словами не нужно указывать типы явно если это за вас сможет сделать вывод типов. Единственное исключение может возникнуть при необходимости повышения семантики кода, что относительно аннотаций типа бывает сравнительно редко.</p></section>\n<section class=\"content__section\" id=\"Вывод примитивных типов\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod primitivnyh tipov\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод примитивных типов</span></h2><p class=\"content__paragraph\">Вывод типов, для значений принадлежащих к так называемым примитивным типам, не таит в себе ничего необычного. Кроме того, будь это переменные, поля, параметры, возвращаемые из функций и методов значения, результат во всех случаях будет идентичным.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> Enums <span class=\"token punctuation\">{</span>\n    Value\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> v0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v0: number</span>\n<span class=\"token keyword\">let</span> v1 <span class=\"token operator\">=</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v1: string</span>\n<span class=\"token keyword\">let</span> v2 <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v2: boolean</span>\n<span class=\"token keyword\">let</span> v3 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v3: symbol</span>\n<span class=\"token keyword\">let</span> v4 <span class=\"token operator\">=</span> Enums<span class=\"token punctuation\">.</span>Value<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v4: Enums</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod primitivnyh tipov dlya konstant (const) i polei tolko dlya chteniya (readonly)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод примитивных типов для констант (const) и полей только для чтения (readonly)</span></h2><p class=\"content__paragraph\">Когда дело доходит до присваивания значений, принадлежащих к примитивным типам, таким конструкциям, как константы (<code>const</code>) и неизменяемые поля (модификатор <code>readonly</code>), поведение вывода типов изменяется.</p><p class=\"content__paragraph\">В случае, когда значение принадлежит к примитивным типам <code>number</code>, <code>string</code> или <code>boolean</code>, вывод типов указывает принадлежность к литеральным примитивным типам, определяемым самим значением.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> v0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v0: 0</span>\n<span class=\"token keyword\">const</span> v1 <span class=\"token operator\">=</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v1: 'text'</span>\n<span class=\"token keyword\">const</span> v2 <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v2: true</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Identifier</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> f0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// f0: 0</span>\n    <span class=\"token keyword\">readonly</span> f1 <span class=\"token operator\">=</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// f1: 'text'</span>\n    <span class=\"token keyword\">readonly</span> f2 <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// f2: true</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если значение принадлежит к типу <code>enum</code>, то вывод типов установит принадлежность к типу <code>enum</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> Enums <span class=\"token punctuation\">{</span>\n    Value\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> v <span class=\"token operator\">=</span> Enums<span class=\"token punctuation\">.</span>Value<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: Enums</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Identifier</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> f <span class=\"token operator\">=</span> Enums<span class=\"token punctuation\">.</span>Value<span class=\"token punctuation\">;</span> <span class=\"token comment\">// f: Enums</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Когда вывод типов встречает значение принадлежащие к типу <code>symbol</code>, его поведение зависит от конструкции, которой присваивается значение. Так, если вывод типов работает с константой, то тип определяется как запрос типа (глава <a href=\"/book/chapters/Type%20Queries%20(%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D1%82%D0%B8%D0%BF%D0%B0),%20Alias%20(%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B%20%D1%82%D0%B8%D0%BF%D0%B0)\">“Type Queries (запросы типа), Alias (псевдонимы типа)”</a>) самой константы. Если вывод типов устанавливает принадлежность к типу неизменяемого поля, то тип будет определен как <code>symbol</code>. Происходит так потому, что вместе с созданием нового экземпляра в системе будет определяться и новый символ, что противоречит правилам установленным для <code>Unique Symbol</code> (глава <a href=\"/book/chapters/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%20Number,%20String,%20Boolean,%20Unique%20Symbol,%20Enum\">“Типы - Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum”</a>).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> v <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// const v: typeof v</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Identifier</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> f <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// f: symbol</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Вывод объектных типов\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod obektnyh tipov\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод объектных типов</span></h2><p class=\"content__paragraph\">С выводом объектных типов не связанно ничего необычного. Кроме того, поведение вывода типов одинаково для всех конструкций.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassType</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">InterfaceType</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TypeAlias</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> typeIntreface<span class=\"token operator\">:</span> InterfaceType<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> typeTypeAlias<span class=\"token operator\">:</span> TypeAlias<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> v0 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v0: { a:number, b:string, c: boolean }</span>\n<span class=\"token keyword\">const</span> v1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v1: { a:number, b:string, c: boolean }</span>\n\n<span class=\"token keyword\">let</span> v3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v3: ClassType</span>\n<span class=\"token keyword\">let</span> v4 <span class=\"token operator\">=</span> typeIntreface<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v4: InterfaceType</span>\n<span class=\"token keyword\">let</span> v5 <span class=\"token operator\">=</span> typeTypeAlias<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v5: number</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Вывод типа для полей класса на основе инициализации их в конструкторе\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod tipa dlya polei klassa na osnove inicializacii ih v konstruktore\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод типа для полей класса на основе инициализации их в конструкторе</span></h2><p class=\"content__paragraph\">Если прочитать главу посвященную конфигурации компилятора станет известно, что при активном флаге <code>--noImplicitAny</code> возникает ошибка, если тело класса включает поля без аннотации типа. Дело в том что вывод типов расценивает поля с явной аннотацией типа как принадлежащие к <code>any</code>, который как раз и не допускает активированный флаг <code>--noImplicitAny</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**\n     * Поля без явной аннотации типа.\n     * Вывод типов определяет их\n     * принадлежность к типу any.\n     * \n     * (property) Square.area: any\n     * (property) Square.sideLength: any\n     * \n     * От этого возникает ошибка -> \n     * Member 'area' implicitly has an 'any' type.(7008)\n     * Member 'sideLength' implicitly has an 'any' type.(7008)\n     */</span>\n    area<span class=\"token punctuation\">;</span>\n    sideLength<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но, к счастью, тип полей без явной аннотации может быть автоматически выведен, если инициализация таких полей происходит в конструкторе.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**\n     * Поля без явной аннотации типа,\n     * но ошибки не возникает, поскольку\n     * вывод типов определяет их принадлежность\n     * к типу number, так как поле sideLength\n     * инициализиируется в конструкторе его параметром \n     * принадлежащим к типу number, а поле area инициализируется\n     * там же с помощью выражения результат которого \n     * также принадлежит к типу number.\n     * \n     * (property) Square.area: number\n     * (property) Square.sideLength: number\n     */</span>\n    area<span class=\"token punctuation\">;</span>\n    sideLength<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span>sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sideLength <span class=\"token operator\">=</span> sideLength<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>area <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sideLength <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Не будет лишним сделать акцент на словах об инициализации в конструкторе, поскольку это условие является обязательным. При попытке инициализации полей вне тела конструктора будет вызвана ошибка, даже если инициализация производится в методе вызываемом из конструктора.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**\n     * Error ->\n     * Member 'area' implicitly has an 'any' type.\n     * \n     */</span>\n    area<span class=\"token punctuation\">;</span>\n    sideLength<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span>sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sideLength <span class=\"token operator\">=</span> sideLength<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>area <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sideLength <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если инициализация полей класса без аннотации по каким-то причинам может не состоятся, то тип будет выведен как объединение включающее так же и тип <code>undefined</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**\n     * [1] ...вывод типов определяет принадлежность\n     * поля sideLength как ->\n     * \n     * (property) Square.sideLength: number | undefined\n     */</span>\n    sideLength<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span>sideLength<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/**\n         * [0] Поскольку инициализация зависи от\n         * условия выражения которое выполнится\n         * только во время выполнения программы...\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sideLength <span class=\"token operator\">=</span> sideLength<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">get</span> <span class=\"token function\">area</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/**\n         * [2] Тем не менее возникает ошибка\n         * поскольку операция возведения в степень\n         * производится над значение которое может\n         * быть undefined\n         * \n         * Error ->\n         * Object is possibly 'undefined'.\n         */</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sideLength <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Вывод объединенных (Union) типов\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod obedinennyh (union) tipov\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод объединенных (Union) типов</span></h2><p class=\"content__paragraph\">С выводом типов объединения (глава <a href=\"/book/chapters/%D0%A2%D0%B8%D0%BF%D1%8B%20-%20Union,%20Intersection\">“Типы - Union, Intersection”</a>) связаны как очевидные, так и нет, случаи.</p><p class=\"content__paragraph\">К очевидным случаям можно отнести массив, состоящий из разных примитивных типов. В этом случае будет выведен очевидный тип <em>объединение</em>, которое определяется типами присутствующих в массиве примитивов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: (string | number | boolean)[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случае получения любого элемента массива, вывод типов также установит принадлежность к объединенному типу.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: (string | number | boolean)[]</span>\n\n<span class=\"token keyword\">let</span> item <span class=\"token operator\">=</span> v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let item: string | number | boolean</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Неочевидные особенности лучше всего начать с примера в котором вывод типа определяет принадлежность значения к массиву состоящему из обычных объектных типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token string\">'text'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token string\">'text'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: { a: number, b: string }[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В примере, вывод типов выводит ожидаемый и предсказуемый результат для массива объектов, чьи типы полностью идентичны. Идентичны они по той причине, что вывод типов установит тип <code>{ a: number, b:string }</code> для всех элементов массива.</p><p class=\"content__paragraph\">Но стоит изменить условие, допустим, убрать объявление одного поля и картина кардинально изменится. Вместо массива обычных объектов, тип будет выведен, как массив объединенного типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token string\">'text'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">6</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: ({ a: number, b: string } | { a: number, b?: undefined } | { a: number, b: boolean })[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Как видно из примера выше, вывод типов приводит все объектные типы, составляющие тип объединение, к единому виду. Он добавляет к типам несуществующие в них, но существующие в других объектных типах, поля, декларируя их как необязательные (глава  <a href=\"/book/chapters/Optional,%20Not-Null,%20Not-Undefined,%20Definite%20Assignment%20Assertion\">“Операторы - Optional, Not-Null, Not-Undefined, Definite Assignment Assertion”</a>). Сделано это для возможности конкретизировать тип любого элемента массива. Простыми словами, чтобы не получить ошибку во время выполнения, любой элемент массива должен иметь общие для всех элементов признаки. Но так как в реальности, в объектах, некоторые члены вовсе могут отсутствовать, вывод типов, чтобы повысить типобезопасность, декларирует их как необязательные. Таким образом он предупреждает разработчика о возможности возникновения ситуации, при которой эти члены будут иметь значение <code>undefined</code>, что и демонстрируется в примере ниже.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token string\">'text'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">6</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: ({ a: number, b: string } | { a: number, b?: undefined } | { a: number, b: boolean })[]</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let a: number</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let b: string | boolean | undefined</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если в качестве значений элементов массива выступают экземпляры классов, не связанных отношением наследования, то они и будут определять тип объединение.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n   <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n   <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v: (A | B)[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случае, если элементы массива являются экземплярами классов, связанных отношением наследования (<em>номинативная типизация</em> <a href=\"/book/chapters/%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B8%D0%B4%D0%B0%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8\">“Экскурс в типизацию - Совместимость типов на основе вида типизации”</a>), то выводимый тип будет ограничен самым базовым типом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span> f0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span> f1 <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span> f2 <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">E</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token punctuation\">{</span> f3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> v3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">E</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v3: A[]</span>\n<span class=\"token keyword\">let</span> v4 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">E</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v4: (B | C | D)[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Те же самые правила применяются при выводе типа значения возвращаемого тернарным оператором.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span> f0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span> f1 <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span> f2 <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">E</span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token punctuation\">{</span> f3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> v0 <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v0: A</span>\n<span class=\"token keyword\">let</span> v1 <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v1: B | C</span>\n<span class=\"token keyword\">let</span> v2 <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v2: C | D</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Так как выражение, расположенное в блоке тернарного оператора, вычисляется на этапе выполнения программы, вывод типов не может знать результата его вычисления на этапе компиляции. Поэтому, чтобы не нарушить типобезопасность, он вынужден указывать объединенный тип, определяемый всеми блоками выражения.</p></section>\n<section class=\"content__section\" id=\"Вывод пересечения (Intersection) с дискриминантными полями\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod peresecheniya (intersection) s diskriminantnymi polyami\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод пересечения (Intersection) с дискриминантными полями</span></h2><p class=\"content__paragraph\">Если при определении типа пересечения, определяющее его множество включает больше одного типа определяющего одноименные дискриминантные поля принадлежащие к разным типам, то такое пересечение определяется как тип <code>never</code>. Данная тема подробно бала рассмотрены в главе <a href=\"/book/chapters/%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B8%D0%BC%D0%B8%D0%BD%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D0%B5%20%D0%9E%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20(Discriminated%20Union)\">\"Типы - Discriminated Union\"</a>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// дискриминантное поле</span>\n\n    a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// дискриминантное поле</span>\n\n    b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    c<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    d<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Как видно типы A и B\n * определяют одноименные\n * дискриминантные поля type\n * принадлежащих к разным типам a и b\n * поэтому тип T будет определен\n * как тип never.\n * \n * type T = never\n */</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">B</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">C</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">D</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но стоит обратить внимание что речь идет только об одноименных полях принадлежащих к разным типа. То есть, если множество определяющее пересечение включает несколько типов с одноименными дискриминантными полями принадлежащих к одному типу, то такое множество будет определено ожидаемым образом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// дискриминантное поле с типом a</span>\n\n    a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// дискриминантное поле с типом b</span>\n\n    b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    c<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">D</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    d<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Как видно типы A и B\n * по-прежднему определяют одноименные\n * дискриминантные поля type, но на этот\n * раз они принадлежат к одному типу a,\n * поэтому тип T будет определен ожидаемым\n * образом.\n * \n * \n * \n * type T = A &amp; B &amp; C &amp; D\n */</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T</span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">B</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">C</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">D</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Вывод типов кортеж (Tuple)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"vyvod tipov kortej (tuple)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вывод типов кортеж (Tuple)</span></h2><p class=\"content__paragraph\">Начать стоит с напоминания, что значение длины кортежа содержащего элементы помеченные как необязательные, принадлежит к типу объединению (<code>Union</code>), который составляют литеральные числовые типы.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>rest<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">boolean</span><span class=\"token operator\">?</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> rest<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> l <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token comment\">// let l: 1 | 2 | 3</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Кроме того, остаточные параметры (<code>...rest</code>), аннотированные с помощью параметра типа, рассматриваются и представляются выводом типа как принадлежащие к типу-кортежу.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>rest<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> rest<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// рассматриваются</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// function f&lt;[number]>(rest_0: number): void</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// function f&lt;[number, string]>(rest_0: number, rest_1: string): void</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// function f&lt;[number, string, boolean]>(rest_0: number, rest_1: string, rest_2: boolean): void</span>\n\n<span class=\"token comment\">// представляются</span>\n\n<span class=\"token keyword\">let</span> v0 <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v0: [number]</span>\n<span class=\"token keyword\">let</span> v1 <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v1: [number, string]</span>\n<span class=\"token keyword\">let</span> v2 <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v2: [number, string, boolean]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если функция, определяющая остаточные параметры принадлежащие к параметру типа будет вызвана с аргументами включающих массив указанный при помощи расширяющего синтаксиса (<em>spread syntax</em>), то тип для него будет выведен в виде остаточного типа <code>...rest</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">tuple</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> args<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> numberAll<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> v0 <span class=\"token operator\">=</span> <span class=\"token function\">tuple</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v0: [number, string, boolean]</span>\n<span class=\"token keyword\">let</span> v1 <span class=\"token operator\">=</span> <span class=\"token function\">tuple</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>numberAll<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v1: [number, ...number[]]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но нужно быть внимательным, так как порядок передачи аргументов, содержащих расширяющий синтаксис, может привести к неочевидным результатам. Дело в том, что остаточный тип определяется не только типами самого массива, но и типами аргументов, переданных после него.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">tuple</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> args<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> numberAll<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> v0 <span class=\"token operator\">=</span> <span class=\"token function\">tuple</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>numberAll<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// let v0: [number, ...number[]]</span>\n<span class=\"token keyword\">let</span> v1 <span class=\"token operator\">=</span> <span class=\"token function\">tuple</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>numberAll<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let v1: [number, ...(string | number)[]]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>","commitInfoAll":[{"committedDate":"2020-09-24T10:23:25Z","message":"book(изменение основного контента): rethink chapter 037\n\nrethink chapter 037","messageHeadline":"book(изменение основного контента): rethink chapter 037","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars3.githubusercontent.com/u/31518738?v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/037\\.\\(Типизация\\) Вывод типов/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"Что такое и для чего нужен TypeScript","sections":[{"name":"Что такое TypeScript","path":"Что такое TypeScript"},{"name":"История TypeScript","path":"История TypeScript"},{"name":"Для чего нужен TypeScript","path":"Для чего нужен TypeScript"},{"name":"Зачем разработчику TypeScript","path":"Зачем разработчику TypeScript"}]},{"name":"Вступление","path":"Вступление","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"Система типов, тип данных, значимые и ссылочные типы","sections":[{"name":"Система Типов","path":"Система Типов"},{"name":"Тип данных (тип)","path":"Тип данных (тип)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"Тип данных, передающийся по значению (примитивный тип)"},{"name":"Тип данных, передающийся по ссылке","path":"Тип данных, передающийся по ссылке"}]},{"name":"Связывание, типизация, вывод типов","path":"Связывание, типизация, вывод типов","sections":[{"name":"Обработка кода компилятором","path":"Обработка кода компилятором"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"Лексический анализ (токенизация - tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"Синтаксический анализ (разбор - parsing)"},{"name":"Семантический анализ","path":"Семантический анализ"},{"name":"Связывание (Binding)","path":"Связывание (Binding)"},{"name":"Типизация","path":"Типизация"},{"name":"Вывод Типов (type inference)","path":"Вывод Типов (type inference)"}]},{"name":"Преобразование типов","path":"Преобразование типов","sections":[{"name":"Неявные Преобразования","path":"Неявные Преобразования"},{"name":"Явные Преобразования","path":"Явные Преобразования"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"Типизированные и нетипизированные языки программирования","sections":[{"name":"Нетипизированные языки","path":"Нетипизированные языки"},{"name":"Типизированные языки","path":"Типизированные языки"}]},{"name":"Статическая и динамическая типизация","path":"Статическая и динамическая типизация","sections":[{"name":"Статическая типизация (Static Typing)","path":"Статическая типизация (Static Typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"Динамическая Типизация (Dynamic Typing)"}]},{"name":"Сильная и слабая типизация","path":"Сильная и слабая типизация","sections":[{"name":"Сильная типизация (strongly typed)","path":"Сильная типизация (strongly typed)"},{"name":"Слабая типизация (weakly typed)","path":"Слабая типизация (weakly typed)"}]},{"name":"Явная и неявная типизация","path":"Явная и неявная типизация","sections":[{"name":"Явная типизация (explicit typing)","path":"Явная типизация (explicit typing)"},{"name":"Неявная типизация (implicit typing)","path":"Неявная типизация (implicit typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"Совместимость типов на основе вида типизации","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"Совместимость типов (Types Compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"Номинативная Типизация (nominative typing)"},{"name":"Структурная Типизация (structural typing)","path":"Структурная Типизация (structural typing)"},{"name":"Утиная Типизация (Duck typing)","path":"Утиная Типизация (Duck typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"Совместимость типов на основе вариантности","sections":[{"name":"Вариантность","path":"Вариантность"},{"name":"Иерархия наследования","path":"Иерархия наследования"},{"name":"Ковариантность","path":"Ковариантность"},{"name":"Контравариантность","path":"Контравариантность"},{"name":"Инвариантность","path":"Инвариантность"},{"name":"Бивариантность","path":"Бивариантность"}]},{"name":"Аннотация Типов","path":"Аннотация Типов","sections":[{"name":"Аннотация Типов - общее","path":"Аннотация Типов - общее"},{"name":"Аннотация типа","path":"Аннотация типа"},{"name":"Синтаксические конструкции var, let, const","path":"Синтаксические конструкции var, let, const"},{"name":"Функции (function)","path":"Функции (function)"},{"name":"Стрелочные Функции (arrow function)","path":"Стрелочные Функции (arrow function)"},{"name":"Классы (class)","path":"Классы (class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"Сравнение Синтаксиса TypeScript и JavaScript"},{"name":"Итог","path":"Итог"}]},{"name":"Базовый Тип Any","path":"Базовый Тип Any","sections":[{"name":"Any (any) произвольный тип","path":"Any (any) произвольный тип"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"Примитивные типы Number, String, Boolean, Symbol, BigInt","sections":[{"name":"Важно","path":"Важно"},{"name":"Number (number) примитивный числовой тип","path":"Number (number) примитивный числовой тип"},{"name":"String (string) примитивный строковый тип","path":"String (string) примитивный строковый тип"},{"name":"Boolean (boolean) примитивный логический тип","path":"Boolean (boolean) примитивный логический тип"},{"name":"Symbol (symbol) примитивный символьный тип","path":"Symbol (symbol) примитивный символьный тип"},{"name":"BigInt (bigint) примитивный числовой тип","path":"BigInt (bigint) примитивный числовой тип"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"Примитивные типы Null, Undefined, Void, Never, Unknown","sections":[{"name":"Важно","path":"Важно"},{"name":"Null (null) примитивный null тип","path":"Null (null) примитивный null тип"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"Undefined (undefined) примитивный неопределенный тип"},{"name":"Void (void) отсутствие конкретного типа","path":"Void (void) отсутствие конкретного типа"},{"name":"Never (never) примитивный тип","path":"Never (never) примитивный тип"},{"name":"Unknown (unknown)","path":"Unknown (unknown)"}]},{"name":"Примитивный Тип Enum","path":"Примитивный Тип Enum","sections":[{"name":"Enum (enum) примитивный перечисляемый тип","path":"Enum (enum) примитивный перечисляемый тип"},{"name":"Перечисления с числовым значением","path":"Перечисления с числовым значением"},{"name":"Перечисления со строковым значением","path":"Перечисления со строковым значением"},{"name":"Смешанное перечисление (mixed enum)","path":"Смешанное перечисление (mixed enum)"},{"name":"Перечисление в качестве типа данных","path":"Перечисление в качестве типа данных"},{"name":"Перечисление const с числовым и строковым значением","path":"Перечисление const с числовым и строковым значением"},{"name":"Когда стоит применять enum?","path":"Когда стоит применять enum?"}]},{"name":"Типы - Union, Intersection","path":"Типы - Union, Intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"Тип Объединение (Union Types)"},{"name":"Тип Пересечение (Intersection Type)","path":"Тип Пересечение (Intersection Type)"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"Type Queries (запросы типа), Alias (псевдонимы типа)","sections":[{"name":"Запросы Типа (Type Queries)","path":"Запросы Типа (Type Queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"Псевдонимы Типов (Type Aliases)"}]},{"name":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","sections":[{"name":"Литеральный тип Number (Numeric Literal Types)","path":"Литеральный тип Number (Numeric Literal Types)"},{"name":"Литеральный тип String (String Literal Types)","path":"Литеральный тип String (String Literal Types)"},{"name":"Шаблонный литеральный тип String (Template String Literal Types)","path":"Шаблонный литеральный тип String (Template String Literal Types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"Литеральный Тип Boolean (Boolean Literal Types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"Литеральный тип Enum (Enum Literal Types)"}]},{"name":"Object, Array, Tuple","path":"Object, Array, Tuple","sections":[{"name":"Object (object) — ссылочный объектный тип","path":"Object (object) — ссылочный объектный тип"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"Array (type[]) ссылочный массивоподобный тип"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"Tuple ([T0, T1, …, Tn]) тип кортеж"}]},{"name":"Function, Functional Types","path":"Function, Functional Types","sections":[{"name":"Function Types - тип функция","path":"Function Types - тип функция"},{"name":"Functional Types - функциональный тип","path":"Functional Types - функциональный тип"},{"name":"this в сигнатуре функции","path":"this в сигнатуре функции"}]},{"name":"Interfaces","path":"Interfaces","sections":[{"name":"Общая теория","path":"Общая теория"},{"name":"Интерфейс в TypeScript","path":"Интерфейс в TypeScript"},{"name":"Объявление (declaration)","path":"Объявление (declaration)"},{"name":"Конвенции именования интерфейсов","path":"Конвенции именования интерфейсов"},{"name":"Реализация интерфейса (implements)","path":"Реализация интерфейса (implements)"},{"name":"Декларация свойств get и set (accessors)","path":"Декларация свойств get и set (accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"Указание интерфейса в качестве типа (interface types)"},{"name":"Расширение интерфейсов (extends interface)","path":"Расширение интерфейсов (extends interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"Расширение интерфейсом класса (extends class)"},{"name":"Описание класса (функции-конструктора)","path":"Описание класса (функции-конструктора)"},{"name":"Описание функционального выражения","path":"Описание функционального выражения"},{"name":"Описание индексных членов в объектных типов","path":"Описание индексных членов в объектных типов"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"Инлайн интерфейсы (Inline Interface)"},{"name":"Слияние интерфейсов","path":"Слияние интерфейсов"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","sections":[{"name":"Индексные члены (определение динамических ключей)","path":"Индексные члены (определение динамических ключей)"},{"name":"Строгая проверка при обращении к динамическим ключам","path":"Строгая проверка при обращении к динамическим ключам"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"Модификаторы доступа (Access Modifiers)","sections":[{"name":"Модификатор доступа public (публичный)","path":"Модификатор доступа public (публичный)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"Модификатор доступа private (закрытый или скрытый)"},{"name":"Модификатор доступа protected (защищенный)","path":"Модификатор доступа protected (защищенный)"},{"name":"Модификаторы доступа и конструкторы класса","path":"Модификаторы доступа и конструкторы класса"},{"name":"Быстрое объявление полей","path":"Быстрое объявление полей"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"Закрытые поля определенные спецификацией ECMAScript","sections":[{"name":"Нативный закрытый (private) модификатор доступа","path":"Нативный закрытый (private) модификатор доступа"}]},{"name":"Абстрактные классы (abstract classes)","path":"Абстрактные классы (abstract classes)","sections":[{"name":"Общие характеристики","path":"Общие характеристики"},{"name":"Теория","path":"Теория"}]},{"name":"Полиморфный тип this","path":"Полиморфный тип this","sections":[{"name":"this - как тип","path":"this - как тип"}]},{"name":"Модификатор readonly (только для чтения)","path":"Модификатор readonly (только для чтения)","sections":[{"name":"Модификатор readonly","path":"Модификатор readonly"}]},{"name":"Definite Assignment Assertion Modifier","path":"Definite Assignment Assertion Modifier","sections":[{"name":"Модификатор утверждения не принадлежности значения к типу undefined","path":"Модификатор утверждения не принадлежности значения к типу undefined"}]},{"name":"Классы — Тонкости","path":"Классы — Тонкости","sections":[{"name":"Классы - Тонкости implements","path":"Классы - Тонкости implements"},{"name":"Частичное слияние интерфейса с классом","path":"Частичное слияние интерфейса с классом"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"Переопределение свойств полями и наоборот при наследовании"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","sections":[{"name":"Нюансы на практике","path":"Нюансы на практике"}]},{"name":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","path":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","sections":[{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"Оператор ! (Non-Null and Non-Undefined Operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"Оператор ! (Definite Assignment Assertion)"}]},{"name":"Обобщения (Generics)","path":"Обобщения (Generics)","sections":[{"name":"Обобщения - общие понятия","path":"Обобщения - общие понятия"},{"name":"Обобщения в TypeScript","path":"Обобщения в TypeScript"},{"name":"Параметры типа - extends (generic constraints)","path":"Параметры типа - extends (generic constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"Параметра типа - значение по умолчанию = (generic parameter defaults)"},{"name":"Параметры типа - как тип данных","path":"Параметры типа - как тип данных"}]},{"name":"Дискриминантное объединение (Discriminated Union)","path":"Дискриминантное объединение (Discriminated Union)","sections":[{"name":"Дискриминантное объединение","path":"Дискриминантное объединение"}]},{"name":"Импорт и экспорт только типа","path":"Импорт и экспорт только типа","sections":[{"name":"Предыстория возникновения import type и export type","path":"Предыстория возникновения import type и export type"},{"name":"import type и export type - форма объявления","path":"import type и export type - форма объявления"},{"name":"Импорт и экспорт только типа на практике","path":"Импорт и экспорт только типа на практике"},{"name":"Вспомогательный флаг --importsNotUsedAsValues","path":"Вспомогательный флаг --importsNotUsedAsValues"}]},{"name":"Утверждение типов (Type Assertion)","path":"Утверждение типов (Type Assertion)","sections":[{"name":"Утверждение типов - общее","path":"Утверждение типов - общее"},{"name":"Утверждение типа <Type> синтаксис","path":"Утверждение типа <Type> синтаксис"},{"name":"Утверждение типа с помощью оператора as","path":"Утверждение типа с помощью оператора as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"Приведение (утверждение) к константе (const assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"Утверждение в сигнатуре (Signature Assertion)"}]},{"name":"Защитники типа","path":"Защитники типа","sections":[{"name":"Защитники Типа - общее","path":"Защитники Типа - общее"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"Сужение диапазона множества типов на основе типа данных"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"Сужение диапазона множества типов на основе доступных членов объекта"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"Сужение диапазона множества типов на основе функции, определенной пользователем"}]},{"name":"Вывод типов","path":"Вывод типов","sections":[{"name":"Вывод типов - общие сведения","path":"Вывод типов - общие сведения"},{"name":"Вывод примитивных типов","path":"Вывод примитивных типов"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)"},{"name":"Вывод объектных типов","path":"Вывод объектных типов"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"Вывод типа для полей класса на основе инициализации их в конструкторе"},{"name":"Вывод объединенных (Union) типов","path":"Вывод объединенных (Union) типов"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"Вывод пересечения (Intersection) с дискриминантными полями"},{"name":"Вывод типов кортеж (Tuple)","path":"Вывод типов кортеж (Tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"Совместимость объектных типов (Compatible Object Types)","sections":[{"name":"Важно","path":"Важно"},{"name":"Совместимость объектных типов в TypeScript","path":"Совместимость объектных типов в TypeScript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"Совместимость функциональных типов (Compatible Function Types)","sections":[{"name":"Важно","path":"Важно"},{"name":"Совместимость параметров","path":"Совместимость параметров"},{"name":"Совместимость возвращаемого значения","path":"Совместимость возвращаемого значения"}]},{"name":"Совместимость объединений (Union Types)","path":"Совместимость объединений (Union Types)","sections":[{"name":"Совместимость","path":"Совместимость"}]},{"name":"Типизация в TypeScript","path":"Типизация в TypeScript","sections":[{"name":"Общие сведения","path":"Общие сведения"},{"name":"Статическая типизация (static typing)","path":"Статическая типизация (static typing)"},{"name":"Сильная типизация (strongly typed)","path":"Сильная типизация (strongly typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"Явно типизированный (explicit typing) с выводом типов (type inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)"},{"name":"Вариантность (variance)","path":"Вариантность (variance)"},{"name":"Наилучший общий тип (Best common type)","path":"Наилучший общий тип (Best common type)"},{"name":"Контекстный тип (Contextual Type)","path":"Контекстный тип (Contextual Type)"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","sections":[{"name":"Запрос ключей keyof","path":"Запрос ключей keyof"},{"name":"Поиск типов (Lookup Types)","path":"Поиск типов (Lookup Types)"},{"name":"Сопоставление типов (Mapped Types)","path":"Сопоставление типов (Mapped Types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"Префиксы + и - в сопоставленных типах"}]},{"name":"Условные типы (Conditional Types)","path":"Условные типы (Conditional Types)","sections":[{"name":"Условные типы на практике","path":"Условные типы на практике"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"Распределительные условные типы (Distributive Conditional Types)"},{"name":"Вывод типов в условном типе","path":"Вывод типов в условном типе"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"Readonly, Partial, Required, Pick, Record","sections":[{"name":"Readonly<T> (сделать члены объекта только для чтения)","path":"Readonly<T> (сделать члены объекта только для чтения)"},{"name":"Partial<T> (сделать все члены объекта необязательными)","path":"Partial<T> (сделать все члены объекта необязательными)"},{"name":"Required<T> (сделать все необязательные члены обязательными)","path":"Required<T> (сделать все необязательные члены обязательными)"},{"name":"Pick (отфильтровать объектный тип)","path":"Pick (отфильтровать объектный тип)"},{"name":"Record<K, T> (динамически определить поле в объектном типе)","path":"Record<K, T> (динамически определить поле в объектном типе)"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","sections":[{"name":"Exclude<T, U> (исключает из T признаки присущие U)","path":"Exclude<T, U> (исключает из T признаки присущие U)"},{"name":"Extract<T, U> (общие для двух типов признаки)","path":"Extract<T, U> (общие для двух типов признаки)"},{"name":"NonNullable<T> (удаляет типы null и undefined)","path":"NonNullable<T> (удаляет типы null и undefined)"},{"name":"ReturnType<T> (получить тип значения возвращаемого функцией)","path":"ReturnType<T> (получить тип значения возвращаемого функцией)"},{"name":"InstanceType<T> (получить через тип класса тип его экземпляра)","path":"InstanceType<T> (получить через тип класса тип его экземпляра)"},{"name":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)","path":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)"},{"name":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)","path":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)"},{"name":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)","path":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","sections":[{"name":"Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)","path":"Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)"},{"name":"ReadonlyArray<T> (неизменяемый массив)","path":"ReadonlyArray<T> (неизменяемый массив)"},{"name":"ReadonlyMap<K, V> (неизменяемая карта)","path":"ReadonlyMap<K, V> (неизменяемая карта)"},{"name":"ReadonlySet<T> (неизменяемое множество)","path":"ReadonlySet<T> (неизменяемое множество)"}]},{"name":"Синтаксические конструкции и операторы","path":"Синтаксические конструкции и операторы","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)"},{"name":"Операнды для delete должны быть необязательными","path":"Операнды для delete должны быть необязательными"}]},{"name":"Типизированный React","path":"Типизированный React","sections":[{"name":"Расширение .tsx","path":"Расширение .tsx"}]},{"name":"Функциональные компоненты","path":"Функциональные компоненты","sections":[{"name":"Определение компонента как Function Declaration","path":"Определение компонента как Function Declaration"},{"name":"Определение компонента как Function Expression","path":"Определение компонента как Function Expression"}]},{"name":"Классовые компоненты","path":"Классовые компоненты","sections":[{"name":"Производные от Component<P, S, SS>","path":"Производные от Component<P, S, SS>"},{"name":"Производные от PureComponent<Props, State, Snapshot>","path":"Производные от PureComponent<Props, State, Snapshot>"}]},{"name":"Универсальные компоненты","path":"Универсальные компоненты","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"Обобщенные компоненты (Generics Component)"}]},{"name":"Типизированные хуки","path":"Типизированные хуки","sections":[{"name":"Предопределенные хуки - useState<T>()","path":"Предопределенные хуки - useState<T>()"},{"name":"Предопределенные хуки - useEffect() и useLayoutEffect()","path":"Предопределенные хуки - useEffect() и useLayoutEffect()"},{"name":"Предопределенные хуки - useContext<T>()","path":"Предопределенные хуки - useContext<T>()"},{"name":"Предопределенные хуки - useReducer<R>()","path":"Предопределенные хуки - useReducer<R>()"},{"name":"Предопределенные хуки - useCallback<T>()","path":"Предопределенные хуки - useCallback<T>()"},{"name":"Предопределенные хуки - useRef<T>()","path":"Предопределенные хуки - useRef<T>()"},{"name":"Предопределенные хуки - useImperativeHandle<T, R>()","path":"Предопределенные хуки - useImperativeHandle<T, R>()"},{"name":"Предопределенные хуки - useMemo<T>()","path":"Предопределенные хуки - useMemo<T>()"},{"name":"Предопределенные хуки - useDebugValue<T>()","path":"Предопределенные хуки - useDebugValue<T>()"},{"name":"Пользовательский хук","path":"Пользовательский хук"}]},{"name":"Контекст (Context)","path":"Контекст (Context)","sections":[{"name":"Определение контекста","path":"Определение контекста"}]},{"name":"HOC (Higher-Order Components)","path":"HOC (Higher-Order Components)","sections":[{"name":"Определение hoc","path":"Определение hoc"},{"name":"Определение hoc на основе функционального компонента","path":"Определение hoc на основе функционального компонента"},{"name":"Определение hoc на основе классового компонента","path":"Определение hoc на основе классового компонента"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"Пространства имен (namespace) и модули (module)","sections":[{"name":"Namespace и module — предназначение","path":"Namespace и module — предназначение"},{"name":"Namespace - определение","path":"Namespace - определение"},{"name":"Модули (export, import) — определение","path":"Модули (export, import) — определение"},{"name":"Конфигурирование проекта","path":"Конфигурирование проекта"}]},{"name":"Настройка рабочего окружения","path":"Настройка рабочего окружения","sections":[{"name":"Настройка рабочего окружения","path":"Настройка рабочего окружения"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"Сборка проекта с помощью tsc (TypeScript compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"Сборка с использованием ссылок на проекты","sections":[{"name":"Ссылки на проекты","path":"Ссылки на проекты"}]},{"name":"Декларации","path":"Декларации","sections":[{"name":"Что такое декларация (Declaration)","path":"Что такое декларация (Declaration)"},{"name":"Установка деклараций с помощью @types","path":"Установка деклараций с помощью @types"},{"name":"Подготовка к созданию декларации","path":"Подготовка к созданию декларации"},{"name":"Разновидности деклараций","path":"Разновидности деклараций"},{"name":"Декларации и область видимости","path":"Декларации и область видимости"},{"name":"Декларации для библиотек с одной точкой входа","path":"Декларации для библиотек с одной точкой входа"},{"name":"Декларации для библиотек с множеством точек входа","path":"Декларации для библиотек с множеством точек входа"},{"name":"Создание деклараций вручную","path":"Создание деклараций вручную"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"Директива с тройным слешем (triple-slash directives)"},{"name":"Импортирование декларации (import)","path":"Импортирование декларации (import)"}]},{"name":"Публикация TypeScript","path":"Публикация TypeScript","sections":[{"name":"Публикация","path":"Публикация"}]},{"name":"Опции компилятора","path":"Опции компилятора","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressExcessPropertyErrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressImplicitAnyIndexErrors"},{"name":"noImplicitAny","path":"noImplicitAny"},{"name":"checkJs","path":"checkJs"},{"name":"JSX","path":"JSX"},{"name":"jsxFactory","path":"jsxFactory"},{"name":"target (t)","path":"target (t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysStrict"},{"name":"strictNullChecks","path":"strictNullChecks"},{"name":"stripInternal","path":"stripInternal"},{"name":"noImplicitThis","path":"noImplicitThis"},{"name":"noImplicitUseStrict","path":"noImplicitUseStrict"},{"name":"baseUrl","path":"baseUrl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootDir"},{"name":"rootDirs","path":"rootDirs"},{"name":"traceResolution","path":"traceResolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"noLib"},{"name":"noResolve","path":"noResolve"},{"name":"noStrictGenericChecks","path":"noStrictGenericChecks"},{"name":"preserveConstEnums","path":"preserveConstEnums"},{"name":"removeComments","path":"removeComments"},{"name":"noUnusedLocals","path":"noUnusedLocals"},{"name":"noUnusedParameters","path":"noUnusedParameters"},{"name":"skipLibCheck","path":"skipLibCheck"},{"name":"declarationDir","path":"declarationDir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeRoots"},{"name":"allowUnusedLabels","path":"allowUnusedLabels"},{"name":"noImplicitReturns","path":"noImplicitReturns"},{"name":"noFallthroughCasesInSwitch","path":"noFallthroughCasesInSwitch"},{"name":"outFile","path":"outFile"},{"name":"allowSyntheticDefaultImports","path":"allowSyntheticDefaultImports"},{"name":"allowUnreachableCode","path":"allowUnreachableCode"},{"name":"allowJs","path":"allowJs"},{"name":"reactNamespace","path":"reactNamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleResolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noEmitHelpers"},{"name":"newLine","path":"newLine"},{"name":"inlineSourceMap","path":"inlineSourceMap"},{"name":"inlineSources","path":"inlineSources"},{"name":"noEmitOnError","path":"noEmitOnError"},{"name":"noEmit","path":"noEmit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downlevelIteration"},{"name":"emitBOM","path":"emitBOM"},{"name":"emitDecoratorMetadata","path":"emitDecoratorMetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceConsistentCasingInFileNames"},{"name":"help (h)","path":"help (h)"},{"name":"importHelpers","path":"importHelpers"},{"name":"isolatedModules","path":"isolatedModules"},{"name":"listEmittedFiles","path":"listEmittedFiles"},{"name":"listFiles","path":"listFiles"},{"name":"sourceRoot","path":"sourceRoot"},{"name":"mapRoot","path":"mapRoot"},{"name":"maxNodeModuleJsDepth","path":"maxNodeModuleJsDepth"},{"name":"project (p)","path":"project (p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version (v)"},{"name":"watch (w)","path":"watch (w)"},{"name":"preserveSymlinks","path":"preserveSymlinks"},{"name":"strictFunctionTypes","path":"strictFunctionTypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctPropertyInitialization"},{"name":"esModuleInterop","path":"esModuleInterop"},{"name":"emitDeclarationsOnly","path":"emitDeclarationsOnly"},{"name":"resolveJsonModule","path":"resolveJsonModule"},{"name":"declarationMap","path":"declarationMap"},{"name":"strictBindCallApply","path":"strictBindCallApply"},{"name":"showConfig","path":"showConfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsBuildInfoFile"},{"name":"allowUmdGlobalAccess","path":"allowUmdGlobalAccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disableSourceOfProjectReferenceRedirect"},{"name":"useDefineForClassFields","path":"useDefineForClassFields"},{"name":"importsNotUsedAsValues","path":"importsNotUsedAsValues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumeChangesOnlyAffectDirectDependencies"},{"name":"watchFile","path":"watchFile"},{"name":"watchDirectory","path":"watchDirectory"},{"name":"fallbackPolling","path":"fallbackPolling"},{"name":"synchronousWatchDirectory","path":"synchronousWatchDirectory"},{"name":"noUncheckedIndexedAccess","path":"noUncheckedIndexedAccess"}]}]}},"staticQueryHashes":["408059355","63159454"]}